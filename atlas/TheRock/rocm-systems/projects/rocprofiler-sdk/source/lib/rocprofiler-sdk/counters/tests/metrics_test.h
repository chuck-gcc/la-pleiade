// MIT License
//
// Copyright (c) 2023-2025 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <string>
#include <unordered_map>
#include <vector>

// Expected values for GFX908. GFX908 was chosen because it is not the first
// arch defined in the XML and it is also an arch that inherits values (from gfx9)
// Layout is: {name, block, event, expression, description}.
static const std::unordered_map<std::string, std::vector<std::vector<std::string>>> basic_gfx908 = {
    {"gfx908",
     {{"SQ_INSTS_VMEM_WR",
       "SQ",
       "28",
       "<None>",
       "The number of VMEM (GPU Memory) write instructions issued (including FLAT/scratch memory). "
       "The value is returned per-SE (aggregate of values in SIMDs in the SE)."},
      {"SQ_INSTS_VMEM_RD",
       "SQ",
       "29",
       "<None>",
       "The number of VMEM (GPU Memory) read instructions issued (including FLAT/scratch memory). "
       "The value is returned per-SE (aggregate of values in SIMDs in the SE)."},
      {"SQ_INSTS_SALU",
       "SQ",
       "31",
       "<None>",
       "Total Number of SALU (Scalar ALU) instructions issued. This value is returned per-SE "
       "(aggregate of values in SIMDs in the SE). See AMD ISAs for more information on SALU "
       "instructions."},
      {"SQ_INSTS_SMEM",
       "SQ",
       "32",
       "<None>",
       "Total number of SMEM (Scalar Memory Read) instructions issued. This value is returned "
       "per-SE (aggregate of values in SIMDs in the SE). See AMD ISAs for more information on SMEM "
       "instructions."},
      {"SQ_INSTS_FLAT",
       "SQ",
       "33",
       "<None>",
       "Total number of FLAT instructions issued. When used in combination with "
       "SQ_ACTIVE_INST_FLAT (cycle count for executing instructions) the average latency of FLAT "
       "instruction execution can be calculated (SQ_ACTIVE_INST_FLAT / SQ_INSTS). This value is "
       "returned per-SE (aggregate of values in SIMDs in the SE)."},
      {"SQ_INSTS_FLAT_LDS_ONLY",
       "SQ",
       "34",
       "<None>",
       "Total number of FLAT instructions issued that read/wrote only from/to LDS (scratch "
       "memory). Values are only populated if EARLY_TA_DONE is enabled. This value is returned "
       "per-SE (aggregate of values in SIMDs in the SE)."},
      {"SQ_INSTS_LDS",
       "SQ",
       "35",
       "<None>",
       "Total number of LDS instructions issued (including FLAT). This value is returned per-SE "
       "(aggregate of values in SIMDs in the SE). See AMD ISAs for more information on LDS "
       "instructions."},
      {"SQ_INSTS_GDS",
       "SQ",
       "36",
       "<None>",
       "Total number of GDS (global data sync) instructions issued. This value is returned per-SE "
       "(aggregate of values in SIMDs in the SE). See AMD ISAs for more information on GDS (global "
       "data sync) instructions."},
      {"SQ_WAIT_INST_LDS",
       "SQ",
       "64",
       "<None>",
       "Number of wave-cycles spent waiting for LDS instruction issue. In units of 4 cycles. "
       "(per-simd, nondeterministic)"},
      {"SQ_ACTIVE_INST_VALU",
       "SQ",
       "72",
       "<None>",
       "Number of cycles each wave spends working on a VALU instructions. This value represents "
       "the number of cycles each wave spends executing vector ALU instructions. On MI200 "
       "platforms, there are 4 VALUs per CU. High values indicates a large amount of time spent "
       "executing vector instructions. This value is returned on a per-SE (aggregate of values in "
       "SIMDs in the SE) basis with units in quad-cycles(4 cycles)."},
      {"SQ_INST_CYCLES_SALU",
       "SQ",
       "85",
       "<None>",
       "The number of cycles needed to execute non-memory read scalar operations (SALU). This "
       "value is returned on a per-SE (aggregate of values in SIMDs in the SE) basis with units in "
       "quad-cycles(4 cycles)."},
      {"SQ_THREAD_CYCLES_VALU",
       "SQ",
       "86",
       "<None>",
       "Number of thread-cycles used to execute VALU operations (similar to INST_CYCLES_VALU but "
       "multiplied by # of active threads). (per-simd)"},
      {"SQ_LDS_BANK_CONFLICT",
       "SQ",
       "94",
       "<None>",
       "The number of cycles LDS (local data store) is stalled by bank conflicts. This value is "
       "returned on a per-SE (aggregate of values in SIMDs in the SE) basis."},
      {"TCC_HIT", "TCC", "17", "<None>", "Number of cache hits."},
      {"TCC_MISS", "TCC", "19", "<None>", "Number of cache misses. UC reads count as misses."},
      {"TCC_EA_WRREQ",
       "TCC",
       "26",
       "<None>",
       "Number of transactions (either 32-byte or 64-byte) going over the TC_EA_wrreq interface. "
       "Atomics may travel over the same interface and are generally classified as write requests. "
       "This does not include probe commands."},
      {"TCC_EA_WRREQ_64B",
       "TCC",
       "27",
       "<None>",
       "Number of 64-byte transactions going (64-byte write or CMPSWAP) over the TC_EA_wrreq "
       "interface."},
      {"TCC_EA_WRREQ_STALL",
       "TCC",
       "30",
       "<None>",
       "Number of cycles a write request was stalled."},
      {"TCC_EA_RDREQ",
       "TCC",
       "38",
       "<None>",
       "Number of TCC/EA read requests (either 32-byte or 64-byte)"},
      {"TCC_EA_RDREQ_32B", "TCC", "39", "<None>", "Number of 32-byte TCC/EA read requests"},
      {"GRBM_COUNT", "GRBM", "0", "<None>", "Tie High - Count Number of Clocks"},
      {"GRBM_GUI_ACTIVE", "GRBM", "2", "<None>", "The GUI is Active"},
      {"SQ_WAVES",
       "SQ",
       "4",
       "<None>",
       "Count number of waves sent to distributed sequencers (SQs). This value represents the "
       "number of waves that are sent to each SQ. This only counts new waves sent since the start "
       "of collection (for dispatch profiling this is the timeframe of kernel execution, for agent "
       "profiling it is the timeframe between start_context and read counter data). A sum of all "
       "SQ_WAVES values will give the total number of waves started by the application during the "
       "collection timeframe. Returns one value per-SE (aggregates of SIMD values)."},
      {"SQ_INSTS_VALU",
       "SQ",
       "26",
       "<None>",
       "The number of VALU (Vector ALU) instructions issued. The value is returned per-SE "
       "(aggregate of values in SIMDs in the SE). See AMD ISAs for more information on VALU "
       "instructions."},
      {"TA_TA_BUSY",
       "TA",
       "15",
       "<None>",
       "TA block is busy. Perf_Windowing not supported for this counter."},
      {"TA_FLAT_READ_WAVEFRONTS",
       "TA",
       "101",
       "<None>",
       "Number of flat opcode reads processed by the TA."},
      {"TA_FLAT_WRITE_WAVEFRONTS",
       "TA",
       "102",
       "<None>",
       "Number of flat opcode writes processed by the TA."},
      {"TCP_TCP_TA_DATA_STALL_CYCLES",
       "TCP",
       "6",
       "<None>",
       "TCP stalls TA data interface. Now Windowed."},
      {"SQ_WAVES_LT_32",
       "SQ",
       "9",
       "<None>",
       "Count number of waves sent <32 active threads sent to SQs. This value represents the "
       "number of waves that an each individual SIMD has enqueued during the collection timeframe "
       "(for dispatch profiling this is the timeframe of kernel execution, for agent profiling it "
       "is the timeframe between start_context and read counter data) with less than 32 threads. A "
       "sum of all SQ_WAVES_LT_32 values will give the total number of waves with 32 threads "
       "enqueued during the collection timeframe by the application. Returns one value per-SE "
       "(aggregates of SIMD values). Useful for checking for wavefront occupancy."},
      {"TCC_ALL_TC_OP_WB_WRITEBACK",
       "TCC",
       "73",
       "<None>",
       "Number of writebacks due to all TC_OP writeback requests."},
      {"GRBM_UTCL2_BUSY",
       "GRBM",
       "34",
       "<None>",
       "The Unified Translation Cache Level-2 (UTCL2) block is busy."},
      {"SPI_RA_SGPR_SIMD_FULL_CSN",
       "SPI",
       "115",
       "<None>",
       "Sum of SIMD where SGPR can't take csn wave when !fits. Source is RA0"},
      {"TCP_TCC_NC_ATOMIC_REQ",
       "TCP",
       "77",
       "<None>",
       "Total atomic requests with NC mtype from this TCP to all TCCs"},
      {"SQC_DCACHE_HITS",
       "SQ",
       "291",
       "<None>",
       "Number of cache hits. (per-SQ, per-Bank, nondeterministic)"},
      {"CPC_CPC_TCIU_IDLE", "CPC", "29", "<None>", "CPC TCIU interface Idle."},
      {"SPI_CSN_WAVE",
       "SPI",
       "52",
       "<None>",
       "Number of waves. Requires SPI_DEBUG_CNTL.DEBUG_PIPE_SEL to select source, "
       "DEBUG_PIPE_SEL = 1, source is CS1; DEBUG_PIPE_SEL = 2, source is CS2; "
       "DEBUG_PIPE_SEL = 3, source is CS3; default, source is CS0;"},
      {"SQ_INST_CYCLES_VMEM_WR",
       "SQ",
       "77",
       "<None>",
       "The number of cycles needed to send addr and cmd data for VMEM write instructions. "
       "This value is returned on a per-SE (aggregate of values in SIMDs in the SE) basis "
       "with units in quad-cycles(4 cycles)."},
      {"TCC_EA0_WR_UNCACHED_32B",
       "TCC",
       "29",
       "<None>",
       "Number of 32-byte write/atomic going over the TC_EA_wrreq interface due to uncached "
       "traffic. Note that CC mtypes can produce uncached requests, and those are included "
       "in this. A 64-byte request will be counted as 2"},
      {"TA_ADDR_STALLED_BY_TD_CYCLES",
       "TA",
       "55",
       "<None>",
       "Number of cycles addr path stalled by TD. Perf_Windowing not supported for this "
       "counter."},
      {"TCP_TOTAL_WRITEBACK_INVALIDATES",
       "TCP",
       "45",
       "<None>",
       "Total number of cache invalidates. Equals TCP_PERF_SEL_TOTAL_WBINVL1+ "
       "TCP_PERF_SEL_TOTAL_WBINVL1_VOL+ TCP_PERF_SEL_CP_TCP_INVALIDATE+ "
       "TCP_PERF_SEL_SQ_TCP_INVALIDATE_VOL. Not Windowed."},
      {"TCC_PROBE_ALL",
       "TCC",
       "10",
       "<None>",
       "Number of external probe requests with with EA_TCC_preq_all== 1. Not windowable."},
      {"TCC_CC_REQ",
       "TCC",
       "7",
       "<None>",
       "The number of coherently cached requests. This is measured at the tag block."},
      {"SPI_RA_REQ_NO_ALLOC_CSN",
       "SPI",
       "85",
       "<None>",
       "Arb cycles with CSn req and no CSn alloc. Source is RA0"},
      {"CPC_ME1_DC0_SPI_BUSY", "CPC", "33", "<None>", "CPC Me1 Processor Busy."},
      {"SQ_WAVES_RESTORED",
       "SQ",
       "159",
       "<None>",
       "Count number of context-restored waves sent to SQs. This value represents the number "
       "of waves whos current register state has been restored from a register bank during "
       "the collection timeframe (for dispatch profiling this is the timeframe of kernel "
       "execution, for agent profiling it is the timeframe between start_context and read "
       "counter data). Context saving/restoring is a slow operation and should be limited. "
       "High values can also indicate that stalling may be taking place (waiting for free "
       "register space). Returns one value per-SE (aggregates of SIMD values)."},
      {"CPF_CPF_TCIU_IDLE", "CPF", "27", "<None>", "CPF TCIU interface Idle."},
      {"TCP_TCC_ATOMIC_WITH_RET_REQ",
       "TCP",
       "71",
       "<None>",
       "Total atomic with return requests from TCP to all TCCs"},
      {"SQC_DCACHE_REQ_READ_8",
       "SQ",
       "326",
       "<None>",
       "Number of constant cache 8 dw read requests. (per-SQ)"},
      {"TCC_STREAMING_REQ",
       "TCC",
       "4",
       "<None>",
       "Number of streaming requests. This is measured at the tag block."},
      {"SQ_INSTS_SMEM_NORM",
       "SQ",
       "161",
       "<None>",
       "Number of SMEM instructions issued normalized to match the level of memory accessed "
       "(i.e. scratch, global, etc). This normalized value is designed to give a hint of "
       "high cost memory actions being used. The formula used to calculate this value is "
       "the following (INST_COUNT *2 for load/store; INST_COUNT*2 atomic; INST_COUNT*2 "
       "memtime; INST_COUNT*4 wb/inv). This value is returned per-SE (aggregate of values "
       "in SIMDs in the SE)."},
      {"SQC_ICACHE_MISSES",
       "SQ",
       "272",
       "<None>",
       "Number of cache misses, includes uncached requests. (per-SQ, per-Bank, "
       "nondeterministic)"},
      {"SQ_WAVES_LT_64",
       "SQ",
       "7",
       "<None>",
       "Count number of waves with <64 active threads sent to SQs. This value represents "
       "the number of waves that an each individual SIMD has enqueued during the collection "
       "timeframe (for dispatch profiling this is the timeframe of kernel execution, for "
       "agent profiling it is the timeframe between start_context and read counter data) "
       "with less than 64 threads. A sum of all SQ_WAVES_LT_64 values will give the total "
       "number of waves with 64 threads enqueued during the collection timeframe by the "
       "application. Returns one value per-SE (aggregates of SIMD values). Useful for "
       "checking for wavefront occupancy."},
      {"TCP_TCC_NC_WRITE_REQ",
       "TCP",
       "76",
       "<None>",
       "Total write requests with NC mtype from this TCP to all TCCs"},
      {"SQ_LDS_ATOMIC_RETURN",
       "SQ",
       "98",
       "<None>",
       "The number of atomic return cycles in LDS (local data store). This value is returned "
       "on a per-SE (aggregate of values in SIMDs in the SE) basis."},
      {"CPF_CMP_UTCL1_STALL_ON_TRANSLATION",
       "CPF",
       "20",
       "<None>",
       "One of the Compute UTCL1s is stalled waiting on translation, XNACK or PENDING "
       "response."},
      {"TCC_CYCLE", "TCC", "1", "<None>", "Number of cycles. Not windowable."},
      {"TCP_GATE_EN2", "TCP", "1", "<None>", "TCP core clocks are turned on. Not Windowed."},
      {"TCC_WRITEBACK",
       "TCC",
       "22",
       "<None>",
       "Number of lines written back to main memory. This includes writebacks of dirty lines "
       "and uncached write/atomic requests."},
      {"SPI_CSN_WINDOW_VALID",
       "SPI",
       "47",
       "<None>",
       "Clock count enabled by perfcounter_start event. Requires "
       "SPI_DEBUG_CNTL.DEBUG_PIPE_SEL to select source, DEBUG_PIPE_SEL = 1, source is CS1; "
       "DEBUG_PIPE_SEL = 2, source is CS2; DEBUG_PIPE_SEL = 3, source is CS3; default, "
       "source is CS0;"},
      {"SQ_ACCUM_PREV_HIRES",
       "SQ",
       "158",
       "<None>",
       "This is a hardware register that can be used for accumulating values for other "
       "counters. This is useful in expressions where you want to integrate over time. "
       "This counter is primarily for use with derived counters supplied by rocprof."},
      {"TCP_TCC_UC_WRITE_REQ",
       "TCP",
       "79",
       "<None>",
       "Total write requests with UC mtype from this TCP to all TCCs"},
      {"TCP_UTCL1_TRANSLATION_MISS", "TCP", "48", "<None>", "Total utcl1 translation misses"},
      {"GRBM_TA_BUSY",
       "GRBM",
       "13",
       "<None>",
       "Any of the Texture Pipes (TA) are busy in the shader engine(s)."},
      {"TCC_EA0_ATOMIC_LEVEL",
       "TCC",
       "37",
       "<None>",
       "The sum of the number of EA atomics in flight. This is primarily meant for measure "
       "average EA atomic latency. Average atomic latency = "
       "TCC_PERF_SEL_EA_WRREQ_ATOMIC_LEVEL/TCC_PERF_SEL_EA_WRREQ_ATOMIC."},
      {"SQ_IFETCH_LEVEL",
       "SQ",
       "89",
       "<None>",
       "Number of inflight instruction fetch requests from the cache. This is a value "
       "returned per-sharder engine. Best used with accumlate() functions as part of a "
       "derived counter."},
      {"TCC_RW_REQ",
       "TCC",
       "8",
       "<None>",
       "The number of RW requests. This is measured at the tag block."},
      {"TCP_TOTAL_WRITE",
       "TCP",
       "32",
       "<None>",
       "Total number of local write pixels/buffers from TA. Equals "
       "TCP_PERF_SEL_TOTAL_MISS_LRU_WRITE+ TCP_PERF_SEL_TOTAL_MISS_EVICT_WRITE"},
      {"TCP_TOTAL_ACCESSES",
       "TCP",
       "29",
       "<None>",
       "Total number of pixels/buffers from TA. Equals "
       "TCP_PERF_SEL_TOTAL_READ+TCP_PERF_SEL_TOTAL_NONREAD"},
      {"SQC_DCACHE_REQ_READ_16",
       "SQ",
       "327",
       "<None>",
       "Number of constant cache 16 dw read requests. (per-SQ)"},
      {"SQ_WAIT_ANY",
       "SQ",
       "58",
       "<None>",
       "Number of wave-cycles spent waiting for anything (per-simd, nondeterministic). "
       "Units in quad-cycles(4 cycles)"},
      {"SQ_CYCLES", "SQ", "2", "<None>", "Clock cycles. Value is returned per-SIMD."},
      {"GRBM_SPI_BUSY",
       "GRBM",
       "11",
       "<None>",
       "Any of the Shader Pipe Interpolators (SPI) are busy in the shader engine(s)."},
      {"SQ_INSTS_MFMA",
       "SQ",
       "27",
       "<None>",
       "Total number of MFMA (Matrix-Fused-Multiply-Add) instructions issued. This value is "
       "returned per-SE (aggregate of values in SIMDs in the SE). See AMD ISAs for more "
       "information on MFMA instructions."},
      {"GRBM_CP_BUSY",
       "GRBM",
       "3",
       "<None>",
       "Any of the Command Processor (CPG/CPC/CPF) blocks are busy."},
      {"SQ_ACCUM_PREV",
       "SQ",
       "1",
       "<None>",
       "This is a hardware register that can be used for accumulating values for other "
       "counters. This is useful in expressions where you want to integrate over time. "
       "Only accumulates once every 4 cycles. This counter is primarily for use with "
       "derived counters supplied by rocprof."},
      {"TCP_TCC_CC_WRITE_REQ",
       "TCP",
       "82",
       "<None>",
       "Total write requests with CC mtype from this TCP to all TCCs"},
      {"SPI_CSN_NUM_THREADGROUPS",
       "SPI",
       "49",
       "<None>",
       "Number of threadgroups launched. Requires SPI_DEBUG_CNTL.DEBUG_PIPE_SEL to select "
       "source, DEBUG_PIPE_SEL = 1, source is CS1; DEBUG_PIPE_SEL = 2, source is CS2; "
       "DEBUG_PIPE_SEL = 3, source is CS3; default, source is CS0;"},
      {"TCP_TCC_NC_READ_REQ",
       "TCP",
       "75",
       "<None>",
       "Total read requests with NC mtype from this TCP to all TCCs"},
      {"TCP_TD_TCP_STALL_CYCLES", "TCP", "7", "<None>", "TD stalls TCP"},
      {"SQ_INSTS_SENDMSG",
       "SQ",
       "40",
       "<None>",
       "Total number of Sendmsg (typically an interrupt to the CPU host) instructions "
       "issued. This value is returned per-SE (aggregate of values in SIMDs in the SE). "
       "See AMD ISAs for more information on Sendmsg instructions."},
      {"TA_ADDR_STALLED_BY_TC_CYCLES",
       "TA",
       "54",
       "<None>",
       "Number of cycles addr path stalled by TC. Perf_Windowing not supported for this "
       "counter."},
      {"TA_BUFFER_WRITE_WAVEFRONTS",
       "TA",
       "46",
       "<None>",
       "Number of buffer write wavefronts processed by TA."},
      {"SQ_ACTIVE_INST_EXP_GDS",
       "SQ",
       "74",
       "<None>",
       "Number of cycles each wave spends working on EXPORT or GDS instructions. This value "
       "represents the number of cycles each wave spends executing instructions "
       "synchronizing workgroups across the device (global data sync). High values "
       "indicates large amounts of time spent waiting on communication between CUs. This "
       "value is returned on a per-SE (aggregate of values in SIMDs in the SE) basis with "
       "units in quad-cycles(4 cycles). See AMD ISAs for more information on GDS "
       "instructions."},
      {"TCC_EA0_WRREQ_DRAM_CREDIT_STALL",
       "TCC",
       "33",
       "<None>",
       "Number of cycles a EA write request was stalled because the interface was out of "
       "DRAM credits."},
      {"TCC_WRITE", "TCC", "13", "<None>", "Number of write requests."},
      {"SPI_RA_VGPR_SIMD_FULL_CSN",
       "SPI",
       "109",
       "<None>",
       "Sum of SIMD where VGPR can't take csn wave when !fits. Source is RA0"},
      {"TCP_TCC_UC_READ_REQ",
       "TCP",
       "78",
       "<None>",
       "Total read requests with UC mtype from this TCP to all TCCs"},
      {"TCC_EA0_RDREQ_DRAM",
       "TCC",
       "102",
       "<None>",
       "Number of TCC/EA read requests (either 32-byte or 64-byte) destined for DRAM (MC)."},
      {"TCC_EA0_WRREQ_IO_CREDIT_STALL",
       "TCC",
       "31",
       "<None>",
       "Number of cycles a EA write request was stalled because the interface was out of IO "
       "credits."},
      {"TCC_TOO_MANY_EA_WRREQS_STALL",
       "TCC",
       "34",
       "<None>",
       "Number of cycles the TCC could not send a EA write request because it already "
       "reached its maximum number of pending EA write requests."},
      {"TCP_TOTAL_READ",
       "TCP",
       "30",
       "<None>",
       "Total number of read pixels/buffers from TA. Equals "
       "TCP_PERF_SEL_TOTAL_HIT_LRU_READ + TCP_PERF_SEL_TOTAL_MISS_LRU_READ + "
       "TCP_PERF_SEL_TOTAL_MISS_EVICT_READ"},
      {"SQ_INSTS_VMEM",
       "SQ",
       "30",
       "<None>",
       "The number of VMEM (GPU Memory) instructions issued. The value is returned per-SE "
       "(aggregate of values in SIMDs in the SE)."},
      {"SPI_RA_WAVE_SIMD_FULL_CSN",
       "SPI",
       "103",
       "<None>",
       "Sum of SIMD where WAVE can't take csn wave when !fits. Source is RA0"},
      {"SQ_INSTS_VSKIPPED",
       "SQ",
       "41",
       "<None>",
       "The number of vector instructions skipped. This can occur when the S_SETVSKIP bit "
       "is enabled on certain instructions. Often this is used as an alturnative to "
       "branching (a compiler may replace a branch with setting this bit to skip the "
       "operation, typically as a performance optimization). The value is returned per-SE "
       "(aggregate of values in SIMDs in the SE)."},
      {"SQ_ITEMS",
       "SQ",
       "14",
       "<None>",
       "Number of valid items per wave. This value is returned on a per-SE (aggregate of "
       "values in SIMDs in the SE) basis."},
      {"SQ_LEVEL_WAVES",
       "SQ",
       "5",
       "<None>",
       "Track the number of waves. Set ACCUM_PREV for the next counter to use this. This "
       "value is returned on a per-SIMD basis."},
      {"SQC_TC_DATA_WRITE_REQ",
       "SQ",
       "265",
       "<None>",
       "Number of data write requests to the TC (No-Masking, nondeterministic)"},
      {"SQ_INST_LEVEL_LDS",
       "SQ",
       "44",
       "<None>",
       "Number of in-flight LDS instructions. This value represents the number of "
       "instructions each wave spends executing instructions accessing the local data store "
       "(data shared between SIMDs on the same CU). Set next counter to ACCUM_PREV and "
       "divide by INSTS_LDS for average latency. Includes FLAT instructions. This value is "
       "returned on a per-SE (aggregate of values in SIMDs in the SE) basis."},
      {"TCP_TOTAL_CACHE_ACCESSES",
       "TCP",
       "60",
       "<None>",
       "Count of total cache line (tag) accesses (includes hits and misses)."},
      {"TA_BUFFER_WAVEFRONTS",
       "TA",
       "44",
       "<None>",
       "Number of buffer wavefronts processed by TA."},
      {"SQ_WAVES_EQ_64",
       "SQ",
       "6",
       "<None>",
       "Count number of waves with exactly 64 active threads sent to SQs. This value "
       "represents the number of waves that an each individual SIMD has enqueued during "
       "the collection timeframe (for dispatch profiling this is the timeframe of kernel "
       "execution, for agent profiling it is the timeframe between start_context and read "
       "counter data) with exactly 64 threads. A sum of all SQ_WAVES_EQ_64 values will "
       "give the total number of waves with 64 threads enqueued during the collection "
       "timeframe by the application. Returns one value per-SE (aggregates of SIMD values). "
       "Useful for checking for wavefront occupancy."},
      {"TCP_WRITE_TAGCONFLICT_STALL_CYCLES",
       "TCP",
       "12",
       "<None>",
       "Tagram conflict stall on a write"},
      {"SQC_TC_INST_REQ",
       "SQ",
       "263",
       "<None>",
       "Number of insruction requests to the TC (No-Masking, nondeterministic)"},
      {"SQC_TC_DATA_ATOMIC_REQ",
       "SQ",
       "266",
       "<None>",
       "Number of data atomic requests to the TC (No-Masking, nondeterministic)"},
      {"TCC_EA0_RDREQ_IO_CREDIT_STALL",
       "TCC",
       "41",
       "<None>",
       "Number of cycles there was a stall because the read request interface was out of IO "
       "credits. Stalls occur regardless of whether a read needed to be performed or not."},
      {"TCP_TCC_CC_ATOMIC_REQ",
       "TCP",
       "83",
       "<None>",
       "Total atomic requests with CC mtype from this TCP to all TCCs"},
      {"TCP_TCC_UC_ATOMIC_REQ",
       "TCP",
       "80",
       "<None>",
       "Total atomic requests with UC mtype from this TCP to all TCCs"},
      {"SQC_ICACHE_MISSES_DUPLICATE",
       "SQ",
       "273",
       "<None>",
       "Number of misses that were duplicates (access to a non-resident, miss pending CL). "
       "(per-SQ, per-Bank, nondeterministic)"},
      {"TCC_EA0_RDREQ_LEVEL",
       "TCC",
       "44",
       "<None>",
       "The sum of the number of TCC/EA read requests in flight. This is primarily meant "
       "for measure average EA read latency. Average read latency = "
       "TCC_PERF_SEL_EA_RDREQ_LEVEL/TCC_PERF_SEL_EA_RDREQ."},
      {"TA_BUFFER_TOTAL_CYCLES", "TA", "49", "<None>", "Number of buffer cycles issued to TC."},
      {"SQ_WAIT_INST_ANY",
       "SQ",
       "61",
       "<None>",
       "Number of wave-cycles spent waiting for any instruction issue. Units in "
       "quad-cycles(4 cycles)."},
      {"SQ_WAVE_CYCLES",
       "SQ",
       "47",
       "<None>",
       "The cycles spent executing waves in the CUs. This value is reported per-SE "
       "(aggregates of SIMD values) and is nondeterministic. Units are in quad-cycles (4 "
       "cycles). Useful for determining how much time is spent executing wave code vs "
       "overhead/waiting. Low cycle count relative to actual number of cycles processed by "
       "the CU can indicate that the CU is stalling or is overloaded."},
      {"TCC_EA0_WRREQ_DRAM",
       "TCC",
       "103",
       "<None>",
       "Number of TCC/EA write requests (either 32-byte of 64-byte) destined for DRAM (MC)."},
      {"TCP_TCR_TCP_STALL_CYCLES", "TCP", "8", "<None>", "TCR stalls TCP_TCR_req interface"},
      {"TCP_TCC_RW_READ_REQ",
       "TCP",
       "85",
       "<None>",
       "Total write requests with RW mtype from this TCP to all TCCs"},
      {"SQ_INST_LEVEL_VMEM",
       "SQ",
       "42",
       "<None>",
       "Number of in-flight VMEM instructions. Set next counter to ACCUM_PREV and divide by "
       "INSTS_VMEM for average latency. Includes FLAT instructions. This value is returned "
       "on a per-SE (aggregate of values in SIMDs in the SE) basis."},
      {"TCP_TCC_CC_READ_REQ",
       "TCP",
       "81",
       "<None>",
       "Total write requests with CC mtype from this TCP to all TCCs"},
      {"SQ_ACTIVE_INST_VMEM",
       "SQ",
       "70",
       "<None>",
       "Number of cycles each wave spends working on a VMEM instructions. This value "
       "represents the number of cycles each wave spends executing vector memory "
       "instructions. High values indicates a large amount of time spent executing vector "
       "memory operations. This value is returned on a per-SE (aggregate of values in "
       "SIMDs in the SE) basis with units in quad-cycles(4 cycles)."},
      {"SQ_IFETCH",
       "SQ",
       "88",
       "<None>",
       "Number of instruction fetch requests from L1I (instruction) cache. This is a value "
       "returned per-SIMD."},
      {"TCP_TCC_READ_REQ", "TCP", "69", "<None>", "Total read requests from TCP to all TCCs"},
      {"SQC_DCACHE_REQ",
       "SQ",
       "290",
       "<None>",
       "Number of requests (post-bank-serialization). (per-SQ, per-Bank)"},
      {"CPC_CPC_STAT_STALL", "CPC", "27", "<None>", "CPC Stalled."},
      {"TCP_GATE_EN1", "TCP", "0", "<None>", "TCP interface clocks are turned on. Not Windowed."},
      {"TCP_PENDING_STALL_CYCLES", "TCP", "22", "<None>", "Stall due to data pending from L2"},
      {"SQC_DCACHE_MISSES_DUPLICATE",
       "SQ",
       "293",
       "<None>",
       "Number of misses that were duplicates (access to a non-resident, miss pending CL). "
       "(per-SQ, per-Bank, nondeterministic)"},
      {"CPF_CPF_STAT_IDLE", "CPF", "24", "<None>", "CPF Idle."},
      {"TCP_VOLATILE", "TCP", "28", "<None>", "Total number of L1 volatile pixels/buffers from TA"},
      {"CPC_CPC_TCIU_BUSY", "CPC", "28", "<None>", "CPC TCIU interface Busy."},
      {"SQC_DCACHE_REQ_READ_2",
       "SQ",
       "324",
       "<None>",
       "Number of constant cache 2 dw read requests. (per-SQ)"},
      {"CPC_CPC_STAT_BUSY", "CPC", "25", "<None>", "CPC Busy."},
      {"TCP_TCP_LATENCY",
       "TCP",
       "65",
       "<None>",
       "Total TCP wave latency (from first clock of wave entering to first clock of wave "
       "leaving), divide by TA_TCP_STATE_READ to avg wave latency"},
      {"TCP_UTCL1_TRANSLATION_HIT", "TCP", "49", "<None>", "Total utcl1 translation hits"},
      {"SQ_INST_LEVEL_SMEM",
       "SQ",
       "43",
       "<None>",
       "Number of in-flight SMEM instructions (*2 load/store; *2 atomic; *2 memtime; *4 "
       "wb/inv). Set next counter to ACCUM_PREV and divide by INSTS_SMEM for average "
       "latency per smem request. Falls slightly short of total request latency because "
       "some fetches are divided into two requests that may finish at different times and "
       "this counter collects the average latency of the two. This value is returned on a "
       "per-SE (aggregate of values in SIMDs in the SE) basis."},
      {"SPI_SWC_CSC_WR",
       "SPI",
       "189",
       "<None>",
       "Number of clocks to write CSC waves to SGPRs (need to multiply this value by 4) "
       "Requires SPI_DEBUG_CNTL.DEBUG_PIPE_SEL to select source, DEBUG_PIPE_SEL = 1, "
       "source is CS1; DEBUG_PIPE_SEL = 2, source is CS2; DEBUG_PIPE_SEL = 3, source is "
       "CS3; default, source is CS0;"},
      {"TCC_READ",
       "TCC",
       "12",
       "<None>",
       "Number of read requests. Compressed reads are included in this, but metadata reads "
       "are not included."},
      {"TD_LOAD_WAVEFRONT",
       "TD",
       "25",
       "<None>",
       "Count the wavefronts with opcode = load, include atomics and store."},
      {"GRBM_EA_BUSY", "GRBM", "35", "<None>", "The Efficiency Arbiter (EA) block is busy."},
      {"SPI_RA_WVLIM_STALL_CSN",
       "SPI",
       "133",
       "<None>",
       "Number of clocks csn is stalled due to WAVE LIMIT."},
      {"SPI_RA_BAR_CU_FULL_CSN",
       "SPI",
       "123",
       "<None>",
       "Sum of CU where BARRIER can't take csn wave when !fits. Source is RA0"},
      {"TD_TD_BUSY",
       "TD",
       "1",
       "<None>",
       "TD is processing or waiting for data. Perf_Windowing not supported for this "
       "counter."},
      {"SQC_ICACHE_REQ", "SQ", "270", "<None>", "Number of requests. (per-SQ, per-Bank)"},
      {"TCC_ATOMIC", "TCC", "14", "<None>", "Number of atomic requests of all types."},
      {"TCP_ATOMIC_TAGCONFLICT_STALL_CYCLES",
       "TCP",
       "13",
       "<None>",
       "Tagram conflict stall on an atomic"},
      {"CPF_CPF_STAT_BUSY", "CPF", "23", "<None>", "CPF Busy."},
      {"TCC_EA0_WRREQ_LEVEL",
       "TCC",
       "35",
       "<None>",
       "The sum of the number of EA write requests in flight. This is primarily meant for "
       "measure average EA write latency. Average write latency = "
       "TCC_PERF_SEL_EA_WRREQ_LEVEL/TCC_PERF_SEL_EA_WRREQ."},
      {"SPI_RA_RES_STALL_CSN",
       "SPI",
       "91",
       "<None>",
       "Arb cycles with CSn req and no CSn fits. Source is RA0"},
      {"TCC_BUSY",
       "TCC",
       "2",
       "<None>",
       "Number of cycles we have a request pending. Not windowable."},
      {"SQC_DCACHE_INPUT_VALID_READYB",
       "SQ",
       "260",
       "<None>",
       "Input stalled by SQC (per-SQ, nondeterministic, unwindowed)"},
      {"SQ_WAVES_SAVED",
       "SQ",
       "160",
       "<None>",
       "Count number of context-saved waves sent to SQs. This value represents the number "
       "of waves whos current register state has been saved to a register bank during the "
       "collection timeframe (for dispatch profiling this is the timeframe of kernel "
       "execution, for agent profiling it is the timeframe between start_context and read "
       "counter data) . Context saving/restoring is a slow operation and should be limited. "
       "High values can also indicate that stalling may be taking place (waiting for free "
       "register space). Returns one value per-SE (aggregates of SIMD values)."},
      {"SQ_ACTIVE_INST_LDS",
       "SQ",
       "71",
       "<None>",
       "Number of cycles each wave spends working on LDS instructions. This value represents "
       "the number of cycles each wave spends executing instructions accessing the local "
       "data store (data shared between SIMDs on the same CU). High values indicates a "
       "large amount of reading/writing to this shared memory space. This value is returned "
       "on a per-SE (aggregate of values in SIMDs in the SE) basis with units in "
       "quad-cycles(4 cycles). See AMD ISAs for more information on LDS instructions."},
      {"TCC_EA0_RD_UNCACHED_32B",
       "TCC",
       "40",
       "<None>",
       "Number of 32-byte TCC/EA read due to uncached traffic. A 64-byte request will be "
       "counted as 2"},
      {"TCP_TCC_RW_WRITE_REQ",
       "TCP",
       "86",
       "<None>",
       "Total write requests with RW mtype from this TCP to all TCCs"},
      {"TCC_EA0_RDREQ_DRAM_CREDIT_STALL",
       "TCC",
       "43",
       "<None>",
       "Number of cycles there was a stall because the read request interface was out of "
       "DRAM credits. Stalls occur regardless of whether a read needed to be performed or "
       "not."},
      {"SPI_VWC_CSC_WR",
       "SPI",
       "195",
       "<None>",
       "Number of clocks to write CSC waves to VGPRs (need to multiply this value by 4) "
       "Requires SPI_DEBUG_CNTL.DEBUG_PIPE_SEL to select source, DEBUG_PIPE_SEL = 1, "
       "source is CS1; DEBUG_PIPE_SEL = 2, source is CS2; DEBUG_PIPE_SEL = 3, source is "
       "CS3; default, source is CS0;"},
      {"SQC_DCACHE_REQ_READ_4",
       "SQ",
       "325",
       "<None>",
       "Number of constant cache 4 dw read requests. (per-SQ)"},
      {"SQ_WAVES_LT_16",
       "SQ",
       "10",
       "<None>",
       "Count number of waves sent <16 active threads sent to SQs. (per-simd, emulated, "
       "global). This value represents the number of waves that an each individual SIMD "
       "has enqueued during the collection timeframe (for dispatch profiling this is the "
       "timeframe of kernel execution, for agent profiling it is the timeframe between "
       "start_context and read counter data) with less than 16 threads. A sum of all "
       "SQ_WAVES_LT_16 values will give the total number of waves with 16 threads enqueued "
       "during the collection timeframe by the application. Returns one value per-SE "
       "(aggregates of SIMD values). Useful for checking for wavefront occupancy."},
      {"SQC_DCACHE_ATOMIC", "SQ", "298", "<None>", "Number of atomic requests. (per-SQ, per-Bank)"},
      {"TCC_EA0_RDREQ_GMI_CREDIT_STALL",
       "TCC",
       "42",
       "<None>",
       "Number of cycles there was a stall because the read request interface was out of "
       "GMI credits. Stalls occur regardless of whether a read needed to be performed or "
       "not."},
      {"SPI_RA_REQ_NO_ALLOC",
       "SPI",
       "79",
       "<None>",
       "Arb cycles with requests but no allocation. Source is RA0"},
      {"SQC_DCACHE_MISSES",
       "SQ",
       "292",
       "<None>",
       "Number of cache misses, includes uncached requests. (per-SQ, per-Bank, "
       "nondeterministic)"},
      {"TCC_NC_REQ",
       "TCC",
       "5",
       "<None>",
       "The number of noncoherently cached requests. This is measured at the tag block."},
      {"SQ_ACTIVE_INST_FLAT",
       "SQ",
       "76",
       "<None>",
       "Number of cycles each wave spends working on FLAT instructions. This value "
       "represents the number of cycles each wave spends executing instructions accessing "
       "flat scratch memory locations. High values indicates a large amount of "
       "reading/writing to scratch memory on the device. This value is returned on a "
       "per-SE (aggregate of values in SIMDs in the SE) basis with units in quad-cycles(4 "
       "cycles). See AMD ISAs for more information on FLAT instructions."},
      {"SQC_TC_DATA_READ_REQ",
       "SQ",
       "264",
       "<None>",
       "Number of data read requests to the TC (No-Masking, nondeterministic)"},
      {"TCP_TCC_READ_REQ_LATENCY",
       "TCP",
       "66",
       "<None>",
       "Total TCP->TCC request latency for reads and atomics with return. Not Windowed."},
      {"CPC_UTCL1_STALL_ON_TRANSLATION",
       "CPC",
       "24",
       "<None>",
       "One of the UTCL1s is stalled waiting on translation, XNACK or PENDING response."},
      {"TCC_PROBE", "TCC", "9", "<None>", "Number of probe requests. Not windowable."},
      {"TA_BUFFER_ATOMIC_WAVEFRONTS",
       "TA",
       "47",
       "<None>",
       "Number of buffer atomic wavefronts processed by TA."},
      {"TA_DATA_STALLED_BY_TC_CYCLES",
       "TA",
       "56",
       "<None>",
       "Number of cycles data path stalled by TC. Perf_Windowing not supported for this "
       "counter."},
      {"TA_FLAT_WAVEFRONTS",
       "TA",
       "100",
       "<None>",
       "Number of flat opcode wavfronts processed by the TA."},
      {"TA_TOTAL_WAVEFRONTS", "TA", "32", "<None>", "Total number of wavefronts processed by TA."},
      {"CPC_CPC_STAT_IDLE", "CPC", "26", "<None>", "CPC Idle."},
      {"CPC_CPC_UTCL2IU_STALL",
       "CPC",
       "32",
       "<None>",
       "CPC UTCL2 interface Stalled waiting on Free, Tags or Translation."},
      {"TCC_NORMAL_WRITEBACK",
       "TCC",
       "68",
       "<None>",
       "Number of writebacks due to requests that are not writeback requests."},
      {"SQ_INST_CYCLES_SMEM",
       "SQ",
       "84",
       "<None>",
       "The number of cycles needed to execute scalar memory reads (SMEM). This value is "
       "returned on a per-SE (aggregate of values in SIMDs in the SE) basis with units in "
       "quad-cycles(4 cycles)."},
      {"SQ_BUSY_CYCLES",
       "SQ",
       "3",
       "<None>",
       "Number of clock cycles there are active waves in a shader engine (as reported by "
       "the distributed sequencer). This value does not denote the number of active waves, "
       "only the clock cycle in which any wave is present in a SE. This value is returned "
       "on a per-shader engine basis in clock cycles."},
      {"SQ_LDS_UNALIGNED_STALL",
       "SQ",
       "96",
       "<None>",
       "Number of cycles LDS (local data store) is stalled processing flat unaligned "
       "load/store ops. This value is returned on a per-SE (aggregate of values in SIMDs "
       "in the SE) basis."},
      {"TA_BUFFER_READ_WAVEFRONTS",
       "TA",
       "45",
       "<None>",
       "Number of buffer read wavefronts processed by TA."},
      {"TA_FLAT_ATOMIC_WAVEFRONTS",
       "TA",
       "103",
       "<None>",
       "Number of flat opcode atomics processed by the TA."},
      {"GRBM_TC_BUSY",
       "GRBM",
       "28",
       "<None>",
       "Any of the Texture Cache Blocks (TCP/TCI/TCA/TCC) are busy."},
      {"GRBM_CPC_BUSY", "GRBM", "30", "<None>", "The Command Processor Compute (CPC) is busy."},
      {"TCP_UTCL1_PERMISSION_MISS", "TCP", "50", "<None>", "Total utcl1 permission misses"},
      {"SPI_RA_BULKY_CU_FULL_CSN",
       "SPI",
       "125",
       "<None>",
       "Sum of CU where BULKY can't take csn wave when !fits. Source is RA0"},
      {"TCP_TA_TCP_STATE_READ", "TCP", "27", "<None>", "Number of state reads"},
      {"TCP_TCC_WRITE_REQ", "TCP", "70", "<None>", "Total write requests from TCP to all TCCs"},
      {"TCP_TCC_RW_ATOMIC_REQ",
       "TCP",
       "87",
       "<None>",
       "Total atomic requests with RW mtype from this TCP to all TCCs"},
      {"SQ_ACTIVE_INST_MISC",
       "SQ",
       "75",
       "<None>",
       "Number of cycles each wave spends working on a BRANCH or SENDMSG instructions. This "
       "value represents the number of cycles each wave spends executing instructions "
       "performing control flow branching and message sending. This value is returned on a "
       "per-SE (aggregate of values in SIMDs in the SE) basis with units in quad-cycles(4 "
       "cycles). See AMD ISAs for more information on BRANCH and SENDMSG instructions."},
      {"SQ_ACTIVE_INST_SCA",
       "SQ",
       "73",
       "<None>",
       "Number of cycles each wave spends working on a SALU or SMEM instructions. This "
       "value represents the number of cycles each wave spends executing scalar ALU or "
       "scalar memory instructions. On MI200/300 platforms, there is a single ALU per CU. "
       "High values indicates a large amount of time spent executing scalar instructions. "
       "This value is returned on a per-SE (aggregate of values in SIMDs in the SE) basis "
       "with units in quad-cycles(4 cycles). See AMD ISAs for more information on SALU "
       "and SMEM instructions."},
      {"TD_COALESCABLE_WAVEFRONT",
       "TD",
       "32",
       "<None>",
       "Count wavefronts that TA finds coalescable."},
      {"SPI_RA_TMP_STALL_CSN",
       "SPI",
       "97",
       "<None>",
       "Cycles where csn wants to req but does not fit in temp space."},
      {"SQ_BUSY_CU_CYCLES",
       "SQ",
       "13",
       "<None>",
       "Number of quad-cycles each CU is busy. Can be used to calculate the percentage of "
       "time each CU is busy. This value is returned on a per-SE (aggregate of values in "
       "SIMDs in the SE) basis with units in quad-cycles(4 cycles)."},
      {"TCA_BUSY",
       "TCA",
       "2",
       "<None>",
       "Number of cycles we have a request pending. Not windowable."},
      {"TCP_TOTAL_ATOMIC_WITH_RET",
       "TCP",
       "38",
       "<None>",
       "Total number of atomic with return pixels/buffers from TA"},
      {"SQC_ICACHE_HITS",
       "SQ",
       "271",
       "<None>",
       "Number of cache hits. (per-SQ, per-Bank, nondeterministic)"},
      {"TCA_CYCLE", "TCA", "1", "<None>", "Number of cycles. Not windowable."},
      {"SPI_CSN_BUSY",
       "SPI",
       "48",
       "<None>",
       "Number of clocks with outstanding waves (SPI or SH). Requires "
       "SPI_DEBUG_CNTL.DEBUG_PIPE_SEL to select source, DEBUG_PIPE_SEL = 1, source is "
       "CS1; DEBUG_PIPE_SEL = 2, source is CS2; DEBUG_PIPE_SEL = 3, source is CS3; "
       "default, source is CS0;"},
      {"TCC_UC_REQ",
       "TCC",
       "6",
       "<None>",
       "The number of uncached requests. This is measured at the tag block."},
      {"SQC_DCACHE_REQ_READ_1",
       "SQ",
       "323",
       "<None>",
       "Number of constant cache 1 dw read requests. (per-SQ)"},
      {"SQ_ACTIVE_INST_ANY",
       "SQ",
       "69",
       "<None>",
       "Number of cycles each wave spends working on any type of instruction. Useful in "
       "determining percentage of time spend executing wave workloads (see WaveExec). This "
       "value is returned on a per-SE (aggregate of values in SIMDs in the SE) basis with "
       "units in quad-cycles(4 cycles)."},
      {"TCP_TCC_ATOMIC_WITHOUT_RET_REQ",
       "TCP",
       "72",
       "<None>",
       "Total atomic without return requests from TCP to all TCCs"},
      {"TCP_TCC_WRITE_REQ_LATENCY",
       "TCP",
       "67",
       "<None>",
       "Total TCP->TCC request latency for writes and atomics without return. Not Windowed."},
      {"TCP_READ_TAGCONFLICT_STALL_CYCLES",
       "TCP",
       "11",
       "<None>",
       "Tagram conflict stall on a read"},
      {"TCC_EA0_WRREQ_STALL",
       "TCC",
       "30",
       "<None>",
       "Number of cycles a write request was stalled."},
      {"SQC_TC_REQ",
       "SQ",
       "262",
       "<None>",
       "Total number of TC requests that were issued by instruction and constant caches. "
       "(No-Masking, nondeterministic)"},
      {"CPF_CPF_STAT_STALL", "CPF", "25", "<None>", "CPF Stalled."},
      {"TCC_ALL_TC_OP_INV_EVICT",
       "TCC",
       "80",
       "<None>",
       "Number of evictions due to all TC_OP invalidate requests."},
      {"SQ_LDS_ADDR_CONFLICT",
       "SQ",
       "95",
       "<None>",
       "Number of cycles LDS (local data store) is stalled by address conflicts. This value "
       "is returned on a per-SE (aggregate of values in SIMDs in the SE) basis."},
      {"SQ_LDS_IDX_ACTIVE",
       "SQ",
       "99",
       "<None>",
       "Number of cycles LDS (local data store) is used for indexed (non-direct,"
       "non-interpolation) operations. This value is returned on a per-SE (aggregate of "
       "values in SIMDs in the SE) basis."},
      {"SQ_INST_CYCLES_VMEM_RD",
       "SQ",
       "78",
       "<None>",
       "The number of cycles needed to send addr and cmd data for VMEM read instructions. "
       "This value is returned on a per-SE (aggregate of values in SIMDs in the SE) basis "
       "with units in quad-cycles(4 cycles)."},
      {"CPC_CPC_UTCL2IU_BUSY", "CPC", "30", "<None>", "CPC UTCL2 interface Busy."},
      {"TCP_UTCL1_REQUEST", "TCP", "47", "<None>", "Total CLIENT_UTCL1 NORMAL requests"},
      {"CPF_CPF_TCIU_STALL",
       "CPF",
       "28",
       "<None>",
       "CPF TCIU interface Stalled waiting on Free, Tags."},
      {"SQ_INSTS_BRANCH",
       "SQ",
       "39",
       "<None>",
       "Total number of BRANCH instructions issued. This value is returned per-SE "
       "(aggregate of values in SIMDs in the SE). This value SHOULD NOT be used in "
       "combination with SQ_ACTIVE_INST_MISC to calculate latency. SQ_ACTIVE_INST_MISC "
       "includes both BRANCH and SENDMSG instructions while this is only BRANCH."},
      {"SPI_RA_LDS_CU_FULL_CSN",
       "SPI",
       "120",
       "<None>",
       "Sum of CU where LDS can't take csn wave when !fits. Source is RA0"},
      {"TD_ATOMIC_WAVEFRONT", "TD", "26", "<None>", "Count the wavefronts with opcode = atomic."},
      {"SQ_INSTS_EXP_GDS",
       "SQ",
       "38",
       "<None>",
       "Total number of EXPORT or GDS (global wave state) instructions issued. When used in "
       "combination with SQ_ACTIVE_INST_EXP_GDS (cycle count for executing instructions) "
       "the average latency of EXPORT/GDS instruction execution can be calculated "
       "(SQ_ACTIVE_INST_EXP_GDS / SQ_INSTS_EXP_GDS). This value is returned per-SE "
       "(aggregate of values in SIMDs in the SE)."},
      {"SQC_TC_STALL",
       "SQ",
       "267",
       "<None>",
       "Valid request stalled TC request interface (no-credits). (No-Masking, "
       "nondeterministic, unwindowed)"},
      {"CPF_CPF_TCIU_BUSY", "CPF", "26", "<None>", "CPF TCIU interface Busy."},
      {"TCC_EA0_WRREQ_GMI_CREDIT_STALL",
       "TCC",
       "32",
       "<None>",
       "Number of cycles a EA write request was stalled because the interface was out of "
       "GMI credits."},
      {"GRBM_CPF_BUSY", "GRBM", "31", "<None>", "The Command Processor Fetchers (CPF) is busy."},
      {"SQ_WAVES_LT_48",
       "SQ",
       "8",
       "<None>",
       "Count number of waves with <48 active threads sent to SQs. This value represents "
       "the number of waves that an each individual SIMD has enqueued during the collection "
       "timeframe (for dispatch profiling this is the timeframe of kernel execution, for "
       "agent profiling it is the timeframe between start_context and read counter data) "
       "with less than 48 threads. A sum of all SQ_WAVES_LT_48 values will give the total "
       "number of waves with 48 threads enqueued during the collection timeframe by the "
       "application. Returns one value per-SE (aggregates of SIMD values). Useful for "
       "checking for wavefront occupancy."},
      {"TCC_EA0_ATOMIC",
       "TCC",
       "36",
       "<None>",
       "Number of transactions going over the TC_EA_wrreq interface that are actually "
       "atomic requests."},
      {"TD_TC_STALL", "TD", "15", "<None>", "TD is stalled waiting for TC data."},
      {"SPI_RA_TGLIM_CU_FULL_CSN",
       "SPI",
       "127",
       "<None>",
       "Cycles where csn wants to req but all CU are at tg_limit"},
      {"TA_BUFFER_COALESCED_WRITE_CYCLES",
       "TA",
       "53",
       "<None>",
       "Number of buffer coalesced write cycles issued to TC."},
      {"TCP_TOTAL_ATOMIC_WITHOUT_RET",
       "TCP",
       "39",
       "<None>",
       "Total number of atomic without return pixels/buffers from TA"},
      {"CPC_ME1_BUSY_FOR_PACKET_DECODE", "CPC", "13", "<None>", "Me1 busy for packet decode."},
      {"SQ_INSTS",
       "SQ",
       "25",
       "<None>",
       "Total number of instructions issued. When used in combination with "
       "SQ_ACTIVE_INST_ANY (cycle count for executing instructions) the average latency of "
       "instruction execution can be calculated (SQ_ACTIVE_INST_ANY / SQ_INSTS). This "
       "value is returned per-SE (aggregate of values in SIMDs in the SE)."},
      {"TCC_NORMAL_EVICT",
       "TCC",
       "74",
       "<None>",
       "Number of evictions due to requests that are not invalidate or probe requests."},
      {"CPC_CPC_UTCL2IU_IDLE", "CPC", "31", "<None>", "CPC UTCL2 interface Idle."},
      {"TCC_REQ",
       "TCC",
       "3",
       "<None>",
       "Number of requests of all types. This is measured at the tag block. This may be "
       "more than the number of requests arriving at the TCC, but it is a good indication "
       "of the total amount of work that needs to be performed."},
      {"TCC_TAG_STALL",
       "TCC",
       "45",
       "<None>",
       "Number of cycles the normal request pipeline in the tag was stalled for any reason. "
       "Normally, stalls of this nature are measured exactly from one point the pipeline, "
       "but that is not the case for this counter. Probes can stall the pipeline at a "
       "variety of places, and there is no single point that can reasonably measure the "
       "total stalls accurately."},
      {"TD_STORE_WAVEFRONT", "TD", "27", "<None>", "Count the wavefronts with opcode = store."},
      {"TA_BUFFER_COALESCED_READ_CYCLES",
       "TA",
       "52",
       "<None>",
       "Number of buffer coalesced read cycles issued to TC."},
      {"SQ_LDS_MEM_VIOLATIONS",
       "SQ",
       "97",
       "<None>",
       "Number of threads that have a memory violation in the LDS (local data store). This "
       "value is returned on a per-SE (aggregate of values in SIMDs in the SE) basis."},
      {"TCC_CLIENT184_REQ",
       "TCC",
       "312",
       "<None>",
       "Number of cycles client184 sent a request to this TCC."},
      {"TCC_CLIENT185_REQ",
       "TCC",
       "313",
       "<None>",
       "Number of cycles client185 sent a request to this TCC."},
      {"TCC_CLIENT186_REQ",
       "TCC",
       "314",
       "<None>",
       "Number of cycles client186 sent a request to this TCC."},
      {"TCC_CLIENT187_REQ",
       "TCC",
       "315",
       "<None>",
       "Number of cycles client187 sent a request to this TCC."},
      {"TCC_CLIENT188_REQ",
       "TCC",
       "316",
       "<None>",
       "Number of cycles client188 sent a request to this TCC."},
      {"TCC_CLIENT189_REQ",
       "TCC",
       "317",
       "<None>",
       "Number of cycles client189 sent a request to this TCC."},
      {"TCC_CLIENT190_REQ",
       "TCC",
       "318",
       "<None>",
       "Number of cycles client190 sent a request to this TCC."},
      {"TCC_CLIENT191_REQ",
       "TCC",
       "319",
       "<None>",
       "Number of cycles client191 sent a request to this TCC."},
      {"TCC_BUBBLE", "TCC", "56", "<None>", "Number of 128-byte read requests sent to EA."}}}};

static const std::unordered_map<std::string, std::vector<std::vector<std::string>>> derived_gfx908 =
    {{"gfx908",
      {{"MAX_WAVE_SIZE", "", "", "wave_front_size", "Max wave size constant"},
       {"SE_NUM", "", "", "array_count/simd_arrays_per_engine", "SE_NUM"},
       {"SIMD_NUM", "", "", "simd_count", "SIMD Number"},
       {"CU_NUM", "", "", "simd_count/simd_per_cu", "CU_NUM"},
       {"GPUBusy",
        "",
        "",
        "100*reduce(GRBM_GUI_ACTIVE,max)/reduce(GRBM_COUNT,max)",
        "The percentage of time GPU was busy."},
       {"Wavefronts", "", "", "reduce(SQ_WAVES,sum)", "Total wavefronts."},
       {"VALUInsts",
        "",
        "",
        "reduce(SQ_INSTS_VALU,sum)/reduce(SQ_WAVES,sum)",
        "The average number of vector ALU instructions executed per work-item (affected by flow "
        "control)."},
       {"SALUInsts",
        "",
        "",
        "reduce(SQ_INSTS_SALU,sum)/reduce(SQ_WAVES,sum)",
        "The average number of scalar ALU instructions executed per work-item (affected by flow "
        "control)."},
       {"SFetchInsts",
        "",
        "",
        "reduce(SQ_INSTS_SMEM,sum)/reduce(SQ_WAVES,sum)",
        "The average number of scalar fetch instructions from the video memory executed per "
        "work-item (affected by flow control)."},
       {"GDSInsts",
        "",
        "",
        "reduce(SQ_INSTS_GDS,sum)/reduce(SQ_WAVES,sum)",
        "The average number of GDS read or GDS write instructions executed per work item "
        "(affected by flow control)."},
       {"MemUnitBusy",
        "",
        "",
        "100*reduce(TA_TA_BUSY,max)/reduce(GRBM_GUI_ACTIVE,max)",
        "The percentage of GPUTime the memory unit is active. The result includes the stall "
        "time (MemUnitStalled). This is measured with all extra fetches and writes and any "
        "cache or memory effects taken into account. Value range: 0% to 100% (fetch-bound)."},
       {"ALUStalledByLDS",
        "",
        "",
        "400*reduce(SQ_WAIT_INST_LDS,sum)/reduce(SQ_WAVES,sum)/reduce(GRBM_GUI_ACTIVE,max)",
        "The percentage of GPUTime ALU units are stalled by the LDS input queue being full or "
        "the output queue being not ready. If there are LDS bank conflicts, reduce them. "
        "Otherwise, try reducing the number of LDS accesses if possible. Value range: 0% "
        "(optimal) to 100% (bad)."},
       {"GPU_UTIL",
        "",
        "",
        "100*reduce(GRBM_GUI_ACTIVE,max)/reduce(GRBM_COUNT,max)",
        "Percentage of the time that GUI is active"},
       {"SQ_WAVES_sum",
        "",
        "",
        "reduce(SQ_WAVES,sum)",
        "Gives the total number of waves currently enqueued by the application during the "
        "collection timeframe (for dispatch profiling this is the timeframe of kernel execution, "
        "for agent profiling it is the timeframe between start_context and read counter data). See "
        "SQ_WAVES for more details."},
       {"TCC_HIT_sum",
        "",
        "",
        "reduce(TCC_HIT,sum)",
        "Number of cache hits. Sum over TCC instances."},
       {"TCC_MISS_sum",
        "",
        "",
        "reduce(TCC_MISS,sum)",
        "Number of cache misses. UC reads count as misses. Sum over TCC instances."},
       {"TCC_EA_RDREQ_32B_sum",
        "",
        "",
        "reduce(TCC_EA_RDREQ_32B,sum)",
        "Number of 32-byte TCC/EA read requests. Sum over TCC instances."},
       {"TCC_EA_RDREQ_sum",
        "",
        "",
        "reduce(TCC_EA_RDREQ,sum)",
        "Number of TCC/EA read requests (either 32-byte or 64-byte). Sum over TCC instances."},
       {"TCC_EA_WRREQ_sum",
        "",
        "",
        "reduce(TCC_EA_WRREQ,sum)",
        "Number of transactions (either 32-byte or 64-byte) going over the TC_EA_wrreq "
        "interface. Sum over TCC instances."},
       {"TCC_EA_WRREQ_64B_sum",
        "",
        "",
        "reduce(TCC_EA_WRREQ_64B,sum)",
        "Number of 64-byte transactions going (64-byte write or CMPSWAP) over the TC_EA_wrreq "
        "interface. Sum over TCC instances."},
       {"TCC_WRREQ_STALL_max",
        "",
        "",
        "reduce(TCC_EA_WRREQ_STALL,max)",
        "Number of cycles a write request was stalled. Max over TCC instances."},
       {"TA_BUSY_avr",
        "",
        "",
        "reduce(TA_TA_BUSY,avr)",
        "TA block is busy. Average over TA instances."},
       {"TA_BUSY_max",
        "",
        "",
        "reduce(TA_TA_BUSY,max)",
        "TA block is busy. Max over TA instances."},
       {"TA_BUSY_min",
        "",
        "",
        "reduce(TA_TA_BUSY,min)",
        "TA block is busy. Min over TA instances."},
       {"TA_FLAT_READ_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_FLAT_READ_WAVEFRONTS,sum)",
        "Number of flat opcode reads processed by the TA. Sum over TA instances."},
       {"TA_FLAT_WRITE_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_FLAT_WRITE_WAVEFRONTS,sum)",
        "Number of flat opcode writes processed by the TA. Sum over TA instances."},
       {"TCP_TCP_TA_DATA_STALL_CYCLES_sum",
        "",
        "",
        "reduce(TCP_TCP_TA_DATA_STALL_CYCLES,sum)",
        "Total number of TCP stalls TA data interface."},
       {"TCP_TCP_TA_DATA_STALL_CYCLES_max",
        "",
        "",
        "reduce(TCP_TCP_TA_DATA_STALL_CYCLES,max)",
        "Maximum number of TCP stalls TA data interface."},
       {"FETCH_SIZE",
        "",
        "",
        "(TCC_EA_RDREQ_32B_sum*32+(TCC_EA_RDREQ_sum-TCC_EA_RDREQ_32B_sum)*64)/1024",
        "The total kilobytes fetched from the video memory. This is measured with all extra "
        "fetches and any cache or memory effects taken into account."},
       {"WRITE_SIZE",
        "",
        "",
        "((TCC_EA_WRREQ_sum-TCC_EA_WRREQ_64B_sum)*32+TCC_EA_WRREQ_64B_sum*64)/1024",
        "The total kilobytes written to the video memory. This is measured with all extra "
        "fetches and any cache or memory effects taken into account."},
       {"WRITE_REQ_32B",
        "",
        "",
        "TCC_EA_WRREQ_64B_sum*2+(TCC_EA_WRREQ_sum-TCC_EA_WRREQ_64B_sum)",
        "The total number of 32-byte effective memory writes."},
       {"VFetchInsts",
        "",
        "",
        "(reduce(SQ_INSTS_VMEM_RD,sum)-TA_FLAT_READ_WAVEFRONTS_sum)/reduce(SQ_WAVES,sum)",
        "The average number of vector fetch instructions from the video memory executed per "
        "work-item (affected by flow control). Excludes FLAT instructions that fetch from video "
        "memory."},
       {"VWriteInsts",
        "",
        "",
        "(reduce(SQ_INSTS_VMEM_WR,sum)-TA_FLAT_WRITE_WAVEFRONTS_sum)/reduce(SQ_WAVES,sum)",
        "The average number of vector write instructions to the video memory executed per "
        "work-item (affected by flow control). Excludes FLAT instructions that write to video "
        "memory."},
       {"FlatVMemInsts",
        "",
        "",
        "(reduce(SQ_INSTS_FLAT,sum)-reduce(SQ_INSTS_FLAT_LDS_ONLY,sum))/reduce(SQ_WAVES,sum)",
        "The average number of FLAT instructions that read from or write to the video memory "
        "executed per work item (affected by flow control). Includes FLAT instructions that "
        "read from or write to scratch."},
       {"LDSInsts",
        "",
        "",
        "(reduce(SQ_INSTS_LDS,sum)-reduce(SQ_INSTS_FLAT_LDS_ONLY,sum))/reduce(SQ_WAVES,sum)",
        "The average number of LDS read or LDS write instructions executed per work item "
        "(affected by flow control).  Excludes FLAT instructions that read from or write to "
        "LDS."},
       {"FlatLDSInsts",
        "",
        "",
        "reduce(SQ_INSTS_FLAT_LDS_ONLY,sum)/reduce(SQ_WAVES,sum)",
        "The average number of FLAT instructions that read or write to LDS executed per work "
        "item (affected by flow control)."},
       {"VALUUtilization",
        "",
        "",
        "100*reduce(SQ_THREAD_CYCLES_VALU,sum)/(reduce(SQ_ACTIVE_INST_VALU,sum)*MAX_WAVE_SIZE)",
        "The percentage of active vector ALU threads in a wave. A lower number can mean either "
        "more thread divergence in a wave or that the work-group size is not a multiple of 64. "
        "Value range: 0\% (bad), 100\% (ideal - no thread divergence)."},
       {"VALUBusy",
        "",
        "",
        "100*reduce(SQ_ACTIVE_INST_VALU,sum)/CU_NUM/reduce(GRBM_GUI_ACTIVE,max)",
        "The percentage of GPUTime vector ALU instructions are processed. Value range: 0\% "
        "(bad) to 100\% (optimal)."},
       {"SALUBusy",
        "",
        "",
        "100*reduce(SQ_INST_CYCLES_SALU,sum)/CU_NUM/reduce(GRBM_GUI_ACTIVE,max)",
        "The percentage of GPUTime scalar ALU instructions are processed. Value range: 0% (bad) "
        "to 100% (optimal)."},
       {"FetchSize",
        "",
        "",
        "FETCH_SIZE",
        "The total kilobytes fetched from the video memory. This is measured with all extra "
        "fetches and any cache or memory effects taken into account."},
       {"WriteSize",
        "",
        "",
        "WRITE_SIZE",
        "The total kilobytes written to the video memory. This is measured with all extra "
        "fetches and any cache or memory effects taken into account."},
       {"MemWrites32B",
        "",
        "",
        "WRITE_REQ_32B",
        "The total number of effective 32B write transactions to the memory"},
       {"L2CacheHit",
        "",
        "",
        "100*reduce(TCC_HIT,sum)/(reduce(TCC_HIT,sum)+reduce(TCC_MISS,sum))",
        "The percentage of fetch, write, atomic, and other instructions that hit the data in L2 "
        "cache. Value range: 0\% (no hit) to 100\% (optimal)."},
       {"MemUnitStalled",
        "",
        "",
        "100*TCP_TCP_TA_DATA_STALL_CYCLES_max/reduce(GRBM_GUI_ACTIVE,max)/SE_NUM",
        "The percentage of GPUTime the memory unit is stalled. Try reducing the number or size "
        "of fetches and writes if possible. Value range: 0\% (optimal) to 100\% (bad)."},
       {"WriteUnitStalled",
        "",
        "",
        "100*TCC_WRREQ_STALL_max/reduce(GRBM_GUI_ACTIVE,max)",
        "The percentage of GPUTime the Write unit is stalled. Value range: 0\% to 100\% (bad)."},
       {"LDSBankConflict",
        "",
        "",
        "100*reduce(SQ_LDS_BANK_CONFLICT,sum)/reduce(GRBM_GUI_ACTIVE,max)/CU_NUM",
        "The percentage of GPUTime LDS is stalled by bank conflicts. Value range: 0\% (optimal) "
        "to 100\% (bad)."},
       {"TCC_WRITEBACK_sum",
        "",
        "",
        "reduce(TCC_WRITEBACK,sum)",
        "Number of lines written back to main memory. This includes writebacks of dirty lines and "
        "uncached write/atomic requests. Sum over TCC instances."},
       {"TCC_CC_REQ_sum",
        "",
        "",
        "reduce(TCC_CC_REQ,sum)",
        "The number of coherently cached requests. This is measured at the tag block. Sum over TCC "
        "instances."},
       {"TA_DATA_STALLED_BY_TC_CYCLES_sum",
        "",
        "",
        "reduce(TA_DATA_STALLED_BY_TC_CYCLES,sum)",
        "Number of cycles data path stalled by TC. Perf_Windowing not supported for this counter. "
        "Sum over TA instances."},
       {"TA_TA_BUSY_sum",
        "",
        "",
        "reduce(TA_TA_BUSY,sum)",
        "TA block is busy. Perf_Windowing not supported for this counter. Sum over TA instances."},
       {"TCP_TOTAL_WRITE_sum",
        "",
        "",
        "reduce(TCP_TOTAL_WRITE,sum)",
        "Total number of local write pixels/buffers from TA. Equals "
        "TCP_PERF_SEL_TOTAL_MISS_LRU_WRITE+ TCP_PERF_SEL_TOTAL_MISS_EVICT_WRITE. Sum over TCP "
        "instances."},
       {"TCP_TCC_CC_WRITE_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_CC_WRITE_REQ,sum)",
        "Total write requests with CC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TA_BUFFER_COALESCED_READ_CYCLES_sum",
        "",
        "",
        "reduce(TA_BUFFER_COALESCED_READ_CYCLES,sum)",
        "Number of buffer coalesced read cycles issued to TC. Sum over TA instances."},
       {"TD_TD_BUSY_sum",
        "",
        "",
        "reduce(TD_TD_BUSY,sum)",
        "TD is processing or waiting for data. Perf_Windowing not supported for this counter. "
        "Sum over TD instances."},
       {"TA_BUFFER_WRITE_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_BUFFER_WRITE_WAVEFRONTS,sum)",
        "Number of buffer write wavefronts processed by TA. Sum over TA instances."},
       {"TCP_TCC_UC_READ_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_UC_READ_REQ,sum)",
        "Total read requests with UC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCP_TCC_UC_WRITE_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_UC_WRITE_REQ,sum)",
        "Total write requests with UC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCP_TCC_CC_READ_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_CC_READ_REQ,sum)",
        "Total write requests with CC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCP_VOLATILE_sum",
        "",
        "",
        "reduce(TCP_VOLATILE,sum)",
        "Total number of L1 volatile pixels/buffers from TA. Sum over TCP instances."},
       {"TCP_TOTAL_CACHE_ACCESSES_sum",
        "",
        "",
        "reduce(TCP_TOTAL_CACHE_ACCESSES,sum)",
        "Count of total cache line (tag) accesses (includes hits and misses). Sum over TCP "
        "instances."},
       {"TA_BUFFER_COALESCED_WRITE_CYCLES_sum",
        "",
        "",
        "reduce(TA_BUFFER_COALESCED_WRITE_CYCLES,sum)",
        "Number of buffer coalesced write cycles issued to TC. Sum over TA instances."},
       {"TCP_TCC_CC_ATOMIC_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_CC_ATOMIC_REQ,sum)",
        "Total atomic requests with CC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCC_EA0_WR_UNCACHED_32B_sum",
        "",
        "",
        "reduce(TCC_EA0_WR_UNCACHED_32B,sum)",
        "Number of 32-byte write/atomic going over the TC_EA_wrreq interface due to uncached "
        "traffic. Note that CC mtypes can produce uncached requests, and those are included in "
        "this. A 64-byte request will be counted as 2. Sum over TCC instances."},
       {"TA_FLAT_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_FLAT_WAVEFRONTS,sum)",
        "Number of flat opcode wavfronts processed by the TA. Sum over TA instances."},
       {"TCP_TOTAL_ACCESSES_sum",
        "",
        "",
        "reduce(TCP_TOTAL_ACCESSES,sum)",
        "Total number of pixels/buffers from TA. Equals "
        "TCP_PERF_SEL_TOTAL_READ+TCP_PERF_SEL_TOTAL_NONREAD. Sum over TCP instances."},
       {"TA_FLAT_ATOMIC_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_FLAT_ATOMIC_WAVEFRONTS,sum)",
        "Number of flat opcode atomics processed by the TA. Sum over TA instances."},
       {"TCP_GATE_EN2_sum",
        "",
        "",
        "reduce(TCP_GATE_EN2,sum)",
        "TCP core clocks are turned on. Not Windowed. Sum over TCP instances."},
       {"TCP_TCC_ATOMIC_WITH_RET_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_ATOMIC_WITH_RET_REQ,sum)",
        "Total atomic with return requests from TCP to all TCCs Sum over TCP instances."},
       {"TCC_EA0_WRREQ_LEVEL_sum",
        "",
        "",
        "reduce(TCC_EA0_WRREQ_LEVEL,sum)",
        "The sum of the number of EA write requests in flight. This is primarily meant for "
        "measure average EA write latency. Average write latency = "
        "TCC_PERF_SEL_EA_WRREQ_LEVEL/TCC_PERF_SEL_EA_WRREQ. Sum over TCC instances."},
       {"TA_BUFFER_ATOMIC_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_BUFFER_ATOMIC_WAVEFRONTS,sum)",
        "Number of buffer atomic wavefronts processed by TA. Sum over TA instances."},
       {"TCP_PENDING_STALL_CYCLES_sum",
        "",
        "",
        "reduce(TCP_PENDING_STALL_CYCLES,sum)",
        "Stall due to data pending from L2. Sum over TCP instances."},
       {"TCC_EA0_ATOMIC_LEVEL_sum",
        "",
        "",
        "reduce(TCC_EA0_ATOMIC_LEVEL,sum)",
        "The sum of the number of EA atomics in flight. This is primarily meant for measure "
        "average EA atomic latency. Average atomic latency = "
        "TCC_PERF_SEL_EA_WRREQ_ATOMIC_LEVEL/TCC_PERF_SEL_EA_WRREQ_ATOMIC. Sum over TCC "
        "instances."},
       {"TCC_NC_REQ_sum",
        "",
        "",
        "reduce(TCC_NC_REQ,sum)",
        "The number of noncoherently cached requests. This is measured at the tag block. Sum over "
        "TCC instances."},
       {"TCP_TCC_RW_WRITE_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_RW_WRITE_REQ,sum)",
        "Total write requests with RW mtype from this TCP to all TCCs. Sum over TCP instances."},
       {"TCC_NORMAL_EVICT_sum",
        "",
        "",
        "reduce(TCC_NORMAL_EVICT,sum)",
        "Number of evictions due to requests that are not invalidate or probe requests. Sum over "
        "TCC instances."},
       {"TCP_TCC_WRITE_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_WRITE_REQ,sum)",
        "Total write requests from TCP to all TCCs Sum over TCP instances."},
       {"TD_LOAD_WAVEFRONT_sum",
        "",
        "",
        "reduce(TD_LOAD_WAVEFRONT,sum)",
        "Count the wavefronts with opcode = load, include atomics and store. Sum over TD "
        "instances."},
       {"TD_STORE_WAVEFRONT_sum",
        "",
        "",
        "reduce(TD_STORE_WAVEFRONT,sum)",
        "Count the wavefronts with opcode = store. Sum over TD instances."},
       {"TCP_TCC_NC_READ_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_NC_READ_REQ,sum)",
        "Total read requests with NC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCP_TOTAL_ATOMIC_WITH_RET_sum",
        "",
        "",
        "reduce(TCP_TOTAL_ATOMIC_WITH_RET,sum)",
        "Total number of atomic with return pixels/buffers from TA. Sum over TCP instances."},
       {"TCP_TCP_LATENCY_sum",
        "",
        "",
        "reduce(TCP_TCP_LATENCY,sum)",
        "Total TCP wave latency (from first clock of wave entering to first clock of wave "
        "leaving), divide by TA_TCP_STATE_READ to avg wave latency Sum over TCP instances."},
       {"TD_COALESCABLE_WAVEFRONT_sum",
        "",
        "",
        "reduce(TD_COALESCABLE_WAVEFRONT,sum)",
        "Count wavefronts that TA finds coalescable. Sum over TD instances."},
       {"TA_BUFFER_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_BUFFER_WAVEFRONTS,sum)",
        "Number of buffer wavefronts processed by TA. Sum over TA instances."},
       {"TCP_TCC_READ_REQ_LATENCY_sum",
        "",
        "",
        "reduce(TCP_TCC_READ_REQ_LATENCY,sum)",
        "Total TCP->TCC request latency for reads and atomics with return. Not Windowed. Sum over "
        "TCP instances."},
       {"TCC_EA0_RDREQ_GMI_CREDIT_STALL_sum",
        "",
        "",
        "reduce(TCC_EA0_RDREQ_GMI_CREDIT_STALL,sum)",
        "Number of cycles there was a stall because the read request interface was out of GMI "
        "credits. Stalls occur regardless of whether a read needed to be performed or not. Sum "
        "over TCC instances."},
       {"TCC_TAG_STALL_sum",
        "",
        "",
        "reduce(TCC_TAG_STALL,sum)",
        "Total number of cycles the normal request pipeline in the tag is stalled for any reason."},
       {"TCP_TA_TCP_STATE_READ_sum",
        "",
        "",
        "reduce(TCP_TA_TCP_STATE_READ,sum)",
        "Number of state reads Sum over TCP instances."},
       {"TCC_ATOMIC_sum",
        "",
        "",
        "reduce(TCC_ATOMIC,sum)",
        "Number of atomic requests of all types. Sum over TCC instances."},
       {"TCP_TCC_READ_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_READ_REQ,sum)",
        "Total read requests from TCP to all TCCs Sum over TCP instances."},
       {"TCP_TCC_NC_ATOMIC_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_NC_ATOMIC_REQ,sum)",
        "Total atomic requests with NC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCC_READ_sum",
        "",
        "",
        "reduce(TCC_READ,sum)",
        "Number of read requests. Compressed reads are included in this, but metadata reads are "
        "not included. Sum over TCC instances."},
       {"TA_BUFFER_TOTAL_CYCLES_sum",
        "",
        "",
        "reduce(TA_BUFFER_TOTAL_CYCLES,sum)",
        "Number of buffer cycles issued to TC. Sum over TA instances."},
       {"TCP_TOTAL_WRITEBACK_INVALIDATES_sum",
        "",
        "",
        "reduce(TCP_TOTAL_WRITEBACK_INVALIDATES,sum)",
        "Total number of cache invalidates. Equals TCP_PERF_SEL_TOTAL_WBINVL1+ "
        "TCP_PERF_SEL_TOTAL_WBINVL1_VOL+ TCP_PERF_SEL_CP_TCP_INVALIDATE+ "
        "TCP_PERF_SEL_SQ_TCP_INVALIDATE_VOL. Not Windowed. Sum over TCP instances."},
       {"TCC_EA0_ATOMIC_sum",
        "",
        "",
        "reduce(TCC_EA0_ATOMIC,sum)",
        "Number of transactions going over the TC_EA_wrreq interface that are actually atomic "
        "requests. Sum over TCC instances."},
       {"TCC_STREAMING_REQ_sum",
        "",
        "",
        "reduce(TCC_STREAMING_REQ,sum)",
        "Number of streaming requests. This is measured at the tag block. Sum over TCC instances."},
       {"TA_ADDR_STALLED_BY_TC_CYCLES_sum",
        "",
        "",
        "reduce(TA_ADDR_STALLED_BY_TC_CYCLES,sum)",
        "Number of cycles addr path stalled by TC. Perf_Windowing not supported for this counter. "
        "Sum over TA instances."},
       {"TCC_EA0_WRREQ_DRAM_sum",
        "",
        "",
        "reduce(TCC_EA0_WRREQ_DRAM,sum)",
        "Number of TCC/EA write requests (either 32-byte of 64-byte) destined for DRAM (MC). Sum "
        "over TCC instances."},
       {"TCC_EA0_RDREQ_DRAM_sum",
        "",
        "",
        "reduce(TCC_EA0_RDREQ_DRAM,sum)",
        "Number of TCC/EA read requests (either 32-byte or 64-byte) destined for DRAM (MC). Sum "
        "over TCC instances."},
       {"TD_ATOMIC_WAVEFRONT_sum",
        "",
        "",
        "reduce(TD_ATOMIC_WAVEFRONT,sum)",
        "Count the wavefronts with opcode = atomic. Sum over TD instances."},
       {"TCC_EA0_RDREQ_DRAM_CREDIT_STALL_sum",
        "",
        "",
        "reduce(TCC_EA0_RDREQ_DRAM_CREDIT_STALL,sum)",
        "Number of cycles there was a stall because the read request interface was out of DRAM "
        "credits. Stalls occur regardless of whether a read needed to be performed or not. Sum "
        "over TCC instances."},
       {"TCC_ALL_TC_OP_INV_EVICT_sum",
        "",
        "",
        "reduce(TCC_ALL_TC_OP_INV_EVICT,sum)",
        "Number of evictions due to all TC_OP invalidate requests. Sum over TCC instances."},
       {"TCP_TD_TCP_STALL_CYCLES_sum",
        "",
        "",
        "reduce(TCP_TD_TCP_STALL_CYCLES,sum)",
        "TD stalls TCP. Sum over TCP instances."},
       {"TCP_WRITE_TAGCONFLICT_STALL_CYCLES_sum",
        "",
        "",
        "reduce(TCP_WRITE_TAGCONFLICT_STALL_CYCLES,sum)",
        "Tagram conflict stall on a write. Sum over TCP instances."},
       {"TCC_EA0_WRREQ_STALL_sum",
        "",
        "",
        "reduce(TCC_EA0_WRREQ_STALL,sum)",
        "Number of cycles a write request was stalled. Sum over TCC instances."},
       {"TCP_TCC_UC_ATOMIC_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_UC_ATOMIC_REQ,sum)",
        "Total atomic requests with UC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCP_ATOMIC_TAGCONFLICT_STALL_CYCLES_sum",
        "",
        "",
        "reduce(TCP_ATOMIC_TAGCONFLICT_STALL_CYCLES,sum)",
        "Tagram conflict stall on an atomic. Sum over TCP instances."},
       {"TCP_GATE_EN1_sum",
        "",
        "",
        "reduce(TCP_GATE_EN1,sum)",
        "TCP interface clocks are turned on. Not Windowed. Sum over TCP instances."},
       {"TD_TC_STALL_sum",
        "",
        "",
        "reduce(TD_TC_STALL,sum)",
        "TD is stalled waiting for TC data. Sum over TD instances."},
       {"TCC_ALL_TC_OP_WB_WRITEBACK_sum",
        "",
        "",
        "reduce(TCC_ALL_TC_OP_WB_WRITEBACK,sum)",
        "Number of writebacks due to all TC_OP writeback requests. Sum over TCC instances."},
       {"TCC_UC_REQ_sum",
        "",
        "",
        "reduce(TCC_UC_REQ,sum)",
        "The number of uncached requests. This is measured at the tag block. Sum over TCC "
        "instances."},
       {"TCC_EA0_RD_UNCACHED_32B_sum",
        "",
        "",
        "reduce(TCC_EA0_RD_UNCACHED_32B,sum)",
        "Number of 32-byte TCC/EA read due to uncached traffic. A 64-byte request will be counted "
        "as 2 Sum over TCC instances."},
       {"TCP_UTCL1_PERMISSION_MISS_sum",
        "",
        "",
        "reduce(TCP_UTCL1_PERMISSION_MISS,sum)",
        "Total utcl1 permission misses Sum over TCP instances."},
       {"TCC_TOO_MANY_EA_WRREQS_STALL_sum",
        "",
        "",
        "reduce(TCC_TOO_MANY_EA_WRREQS_STALL,sum)",
        "Number of cycles the TCC could not send a EA write request because it already reached its "
        "maximum number of pending EA write requests. Sum over TCC instances."},
       {"TCP_TCC_WRITE_REQ_LATENCY_sum",
        "",
        "",
        "reduce(TCP_TCC_WRITE_REQ_LATENCY,sum)",
        "Total TCP->TCC request latency for writes and atomics without return. Not Windowed. Sum "
        "over TCP instances."},
       {"TCC_REQ_sum",
        "",
        "",
        "reduce(TCC_REQ,sum)",
        "Number of requests of all types. This is measured at the tag block. This may be more "
        "than the number of requests arriving at the TCC, but it is a good indication of the "
        "total amount of work that needs to be performed. Sum over TCC instances."},
       {"TCP_TCR_TCP_STALL_CYCLES_sum",
        "",
        "",
        "reduce(TCP_TCR_TCP_STALL_CYCLES,sum)",
        "TCR stalls TCP_TCR_req interface. Sum over TCP instances."},
       {"TCP_UTCL1_REQUEST_sum",
        "",
        "",
        "reduce(TCP_UTCL1_REQUEST,sum)",
        "Total CLIENT_UTCL1 NORMAL requests Sum over TCP instances."},
       {"TCP_TCC_ATOMIC_WITHOUT_RET_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_ATOMIC_WITHOUT_RET_REQ,sum)",
        "Total atomic without return requests from TCP to all TCCs Sum over TCP instances."},
       {"TA_ADDR_STALLED_BY_TD_CYCLES_sum",
        "",
        "",
        "reduce(TA_ADDR_STALLED_BY_TD_CYCLES,sum)",
        "Number of cycles addr path stalled by TD. Perf_Windowing not supported for this counter. "
        "Sum over TA instances."},
       {"TCP_TCC_NC_WRITE_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_NC_WRITE_REQ,sum)",
        "Total write requests with NC mtype from this TCP to all TCCs Sum over TCP instances."},
       {"TCC_EA0_RDREQ_LEVEL_sum",
        "",
        "",
        "reduce(TCC_EA0_RDREQ_LEVEL,sum)",
        "The sum of the number of TCC/EA read requests in flight. This is primarily meant for "
        "measure average EA read latency. Average read latency = "
        "TCC_PERF_SEL_EA_RDREQ_LEVEL/TCC_PERF_SEL_EA_RDREQ. Sum over TCC instances."},
       {"TCC_RW_REQ_sum",
        "",
        "",
        "reduce(TCC_RW_REQ,sum)",
        "The number of RW requests. This is measured at the tag block. Sum over TCC instances."},
       {"TCC_EA0_WRREQ_IO_CREDIT_STALL_sum",
        "",
        "",
        "reduce(TCC_EA0_WRREQ_IO_CREDIT_STALL,sum)",
        "Number of cycles a EA write request was stalled because the interface was out of IO "
        "credits. Sum over TCC instances."},
       {"TCP_READ_TAGCONFLICT_STALL_CYCLES_sum",
        "",
        "",
        "reduce(TCP_READ_TAGCONFLICT_STALL_CYCLES,sum)",
        "Tagram conflict stall on a read. Sum over TCP instances."},
       {"TCC_BUSY_sum",
        "",
        "",
        "reduce(TCC_BUSY,sum)",
        "Number of cycles we have a request pending. Not windowable. Sum over TCC instances."},
       {"TCC_BUSY_avr", "", "", "reduce(TCC_BUSY,avr)", "TCC_BUSY avr over all memory channels."},
       {"TCC_PROBE_sum",
        "",
        "",
        "reduce(TCC_PROBE,sum)",
        "Number of probe requests. Not windowable. Sum over TCC instances."},
       {"TCC_PROBE_ALL_sum",
        "",
        "",
        "reduce(TCC_PROBE_ALL,sum)",
        "Number of external probe requests with with EA_TCC_preq_all== 1. Not windowable. Sum "
        "over TCC instances."},
       {"TA_BUFFER_READ_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_BUFFER_READ_WAVEFRONTS,sum)",
        "Number of buffer read wavefronts processed by TA. Sum over TA instances."},
       {"TCP_TOTAL_READ_sum",
        "",
        "",
        "reduce(TCP_TOTAL_READ,sum)",
        "Total number of read pixels/buffers from TA. Equals TCP_PERF_SEL_TOTAL_HIT_LRU_READ + "
        "TCP_PERF_SEL_TOTAL_MISS_LRU_READ + TCP_PERF_SEL_TOTAL_MISS_EVICT_READ. Sum over TCP "
        "instances."},
       {"TCC_WRITE_sum",
        "",
        "",
        "reduce(TCC_WRITE,sum)",
        "Number of write requests. Sum over TCC instances."},
       {"TCC_EA0_RDREQ_IO_CREDIT_STALL_sum",
        "",
        "",
        "reduce(TCC_EA0_RDREQ_IO_CREDIT_STALL,sum)",
        "Number of cycles there was a stall because the read request interface was out of IO "
        "credits. Stalls occur regardless of whether a read needed to be performed or not. Sum "
        "over TCC instances."},
       {"TCC_EA0_WRREQ_GMI_CREDIT_STALL_sum",
        "",
        "",
        "reduce(TCC_EA0_WRREQ_GMI_CREDIT_STALL,sum)",
        "Number of cycles a EA write request was stalled because the interface was out of GMI "
        "credits. Sum over TCC instances."},
       {"TCP_UTCL1_TRANSLATION_HIT_sum",
        "",
        "",
        "reduce(TCP_UTCL1_TRANSLATION_HIT,sum)",
        "Total utcl1 translation hits Sum over TCP instances."},
       {"TCC_CYCLE_sum",
        "",
        "",
        "reduce(TCC_CYCLE,sum)",
        "Number of cycles. Not windowable. Sum over TCC instances."},
       {"TCC_EA0_WRREQ_DRAM_CREDIT_STALL_sum",
        "",
        "",
        "reduce(TCC_EA0_WRREQ_DRAM_CREDIT_STALL,sum)",
        "Number of cycles a EA write request was stalled because the interface was out of DRAM "
        "credits. Sum over TCC instances."},
       {"TCP_TCC_RW_ATOMIC_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_RW_ATOMIC_REQ,sum)",
        "Total atomic requests with RW mtype from this TCP to all TCCs. Sum over TCP instances."},
       {"TCP_TCC_RW_READ_REQ_sum",
        "",
        "",
        "reduce(TCP_TCC_RW_READ_REQ,sum)",
        "Total write requests with RW mtype from this TCP to all TCCs. Sum over TCP instances."},
       {"TCP_UTCL1_TRANSLATION_MISS_sum",
        "",
        "",
        "reduce(TCP_UTCL1_TRANSLATION_MISS,sum)",
        "Total utcl1 translation misses Sum over TCP instances."},
       {"TA_TOTAL_WAVEFRONTS_sum",
        "",
        "",
        "reduce(TA_TOTAL_WAVEFRONTS,sum)",
        "Total number of wavefronts processed by TA. Sum over TA instances."},
       {"TCP_TOTAL_ATOMIC_WITHOUT_RET_sum",
        "",
        "",
        "reduce(TCP_TOTAL_ATOMIC_WITHOUT_RET,sum)",
        "Total number of atomic without return pixels/buffers from TA Sum over TCP instances."},
       {"TCC_NORMAL_WRITEBACK_sum",
        "",
        "",
        "reduce(TCC_NORMAL_WRITEBACK,sum)",
        "Number of writebacks due to requests that are not writeback requests. Sum over TCC "
        "instances."},
       {"TCC_BUBBLE_sum",
        "",
        "",
        "reduce(TCC_BUBBLE,sum)",
        "Number of 128-byte read requests sent to EA. Sum over all TCC instances."}}}};
